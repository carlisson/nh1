#!/bin/bash

shopt -s expand_aliases

# GLOBALS
_1VERSION=0.118

_1MODULES=(app audio backup canva misc network rpg)

_1DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
_1RC="$_1DIR/$(basename "${BASH_SOURCE[0]}")"
_1UDATA="$HOME/.norg"
_1GDATA="/opt/norg"
if [ "$_1DIR" = "/usr/bin" ]
then
	_1LIB="/usr/lib/norg"
elif [ "$_1DIR" = "/usr/local/bin" ]
then
	_1LIB="/usr/local/lib/norg"
else
	_1LIB="$_1DIR/lib"
fi
_1LOCAL="$_1UDATA/local"
_1REMOTE="$_1UDATA/remote"
_1PLUS="$_1UDATA/plus"

# Gettext configure
source gettext.sh
alias _1text="TEXTDOMAINDIR="$_1LIB/locale" gettext 'NH1'"

_1REMPORT=8097
_1REMFILE="$_1UDATA/servers.list"
if [ ! -f "$_1REMFILE" ]
then
	touch "$_1REMFILE"
fi
_1REMLIST=$(cat "$_1REMFILE")

_1COLOR=6
_1PCOLOR=5 # Pending
_1XCOLOR=3 # Experimental
_1WCOLOR=2 # Working
_1DCOLOR=1 # Deprecated

_1MENUCOL=13
_1VERBOSE=0 # 0 - disabled; 1 - enabled

#STARTING
mkdir -p "$_1LOCAL"
mkdir -p "$_1REMOTE"
mkdir -p "$_1PLUS"

# Run it for all modules
# @param Command. Replace -=- by module name
function _1modrun {
	local _COMM _MOD _AUX
	_COMM="$1"
	for _MOD in "${_1MODULES[@]}"
	do
		_AUX=$(echo "$_COMM" | sed "s/-=-/$_MOD/")
		if [ "$(type -t $_AUX)" = 'function' ]
		then
			$_AUX
		elif [ "$(type -t $_AUX)" = 'builtin' ]
		then
			eval $_AUX
		fi
	done
}

# IMPORT MODULES
_1modrun "source \"$_1LIB/-=-.bashrc\""

# Print a line to build help menu
# @param Status of command
# @param Command name
# @param Command description
# @param (optional) list of commands to check
function _1menuitem {
	if [ $# -gt 2 ]
	then
		# Possible status:
		#  W - working
		#  X - experimental
		#  P - planning
		#  D - deprecated
		local mi_status="$1"
		local mi_comm="$2"
		local mi_csize=${#mi_comm}
		local mi_descr="$3"
		local mi_color=7

		case "$mi_status" in
			"W") mi_color=$_1WCOLOR ;;
			"X") mi_color=$_1XCOLOR ;;
			"P") mi_color=$_1PCOLOR ;;
			"D") mi_color=$_1DCOLOR ;;
		esac

		if [ $# -gt 3 ]
		then
			if ! 1check -s "${@:4:$#+1}"
			then
				return
			fi
		fi
		local mi_spaces=$(($_1MENUCOL - $mi_csize +2))
		1tint $mi_color "$mi_comm"
		printf ' %.0s' $(seq 1 $mi_spaces)
		echo "$mi_descr"
	else
		echo "You need to give status, command name, message and dependencies"
	fi
}

# Menu for NH1
function NH1 {
	local _MOD
		echo " -------------------------------------"
		echo -n "            "
    1tint "NH1 $_1VERSION"
		echo
		echo " -------------------------------------"
    echo

		# Load internal menus
		_1modrun _nh1-=-.menu
		
		echo "___ Main ___"
		_1menuitem W 1bashrc "$(_1text "Modify .bashrc to NH1 starts on bash start")"
		_1menuitem W 1clean "$(_1text "Clean NH1 from memory (undo NH1 charge)")"
		_1menuitem W 1tint "$(_1text "Write a string in another color")"
		_1menuitem X 1translate $(_1text "Create and apply translation for NH1.")
		_1menuitem W 1update "$(_1text "Update your NH1, using git")" git
		_1menuitem X 1verbose "$(_1text "Enable/disable verbose mode")"
		_1menuitem W 1version "$(_1text "List NH1 version and latest changes/updates")"

		echo
		echo -n "   "
		1tint $_1PCOLOR $(_1text "planning")
		echo -n "   "
		1tint $_1XCOLOR $(_1text "experimental")
		echo -n "   "
		1tint $_1WCOLOR $(_1text "working")
		echo -n "   "
		1tint $_1DCOLOR $(_1text "deprecated")
		echo
		echo " -------------------------------------"
		echo "         $(_1text "Power-up your shell")"
		echo " -------------------------------------"
    echo
}

# Set text color in shell
# @param The color number (optional)
# @param Text to 1tint
function 1tint {
	local COLOR MSG
	if [ $# -eq 0 ]
	then
		_1text "You need to put a string and a color number (optional)"
		1tint 0 "0 $(_1text black)"; echo
		1tint 1 "1 $(_1text red)"; echo
		1tint 2 "2 $(_1text green)"; echo
		1tint 3 "3 $(_1text yellow)"; echo
		1tint 4 "4 $(_1text blue)"; echo
		1tint 5 "5 $(_1text magenta)"; echo
		1tint 6 "6 $(_1text cyan)"; echo
		1tint 7 "7 $(_1text white)"; echo
		return 1
	fi
	if [ $# -eq 1 ]
	then
		COLOR=$_1COLOR
		MSG=$1
	else
		COLOR=$1
		MSG=$2
	fi
	tput setaf $COLOR
	echo -n $MSG
	tput sgr0
	return 0
}

# Alias like
function 1help { NH1 ; }

# Print only if NH1 is in verbose mode
# @param Message to print
function _1verb {
	if [ $_1VERBOSE -gt 0 ]
	then
		1tint 3 "â–²"
		echo -n ' '
		1tint ${FUNCNAME[ 1 ]}
		echo ": $1"
	fi
}

# Run the command as root
# @param Command
function _1sudo {
    if [ "$EUID" -eq 0 ]
    then
        $@
    else
        sudo $@
    fi
}

# Check if a program exists. Finish NH1 if it do not exists.
# @param Program to check
function 1check {
	local CFAILS=0
	local SILENT=0
	for PROG in $*
	do
		if [ "$PROG" = "-s" ]
		then
		  SILENT=1
		else
			if [ -z "$(whereis -u "$PROG")" ]
			then
				if [ $SILENT -eq 1 ]
				then
	        		_1verb $(printf "$(_1text "%s is missing for %s")" $PROG $USER)
				else
					printf "$(_1text "Program %s does not exist or it is unavailable for %s.")\n" $PROG $USER
			  fi
				CFAILS=$((CFAILS+1))
			fi
		fi
	done
	if [ $CFAILS -gt 0 ]
	then
		return 1
	else
		return 0
	fi
}

# Modify ~/.bashrc to init NH1 on bash start
function 1bashrc {
    local S1="source $_1RC"
    if grep "$S1" ~/.bashrc > /dev/null
    then
      _1text "NH1 is already installed in your profile. Run NH1 to see all commands available."
    else
			printf "Installing NH1 in %s/.bashrc... " $HOME
    	echo "$S1" >> ~/.bashrc
			_1text "Done!"
    fi
}

# Reload NH1 and all related modules
function 1refresh {
	local LOCAL1RC=$_1RC
	_1verb "$(printf "$(_1text "After destroy variables, I will load %s.")" $_1RC)"
	1clean
	source "$LOCAL1RC"
	_1verb $(_1text "Done!")
}

# Get git credentials to update NH1
function 1update {
	if 1check git
	then
		pushd "$_1LIB/.." || return 1
		git pull
		popd || return 2
		# shellcheck source=/dev/null
		1refresh
		1version
		echo
	fi
}


# List version software and list latest entries from changelog
function 1version {
	echo "NH1 $_1VERSION"
	echo
	tail "$_1LIB/changelog.txt"
}

# Clean all variables set by nh1
function 1clean {
	_1verb "$(_1text "Destroying all variables...")"
	unset _1VERSION _1DIR _1RC _1LIB _1LOCAL _1REMOTE _1PLUS _1COLOR _1VERBOSE
	unset -f NH1 1tint _1verb _1sudo 1check 1bashrc 1refresh 1update 1version 
	unset -f 1clean 1help _1compl _1list 1translate
    _1modrun "_nh1-=-.clean"
}

# Enable or disable verbose mode
# @param (optional) Bit (0/1) to set verbose mode. Default: invvert current
function 1verbose {
	local NEWV=$_1VERBOSE
	if [ $# -eq 1 ]
	then
		if [ $1 -eq 1 ]
		then
			_1VERBOSE=1
			_1verb "$(_1text "Verbose mode is on")"
		else
			_1verb "$(_1text "Verbose mode is off")"
			_1VERBOSE=0
		fi
		return
	fi
	# invert verbose
	if [ $NEWV -eq 1 ]
	then
		_1verb "$(_1text "Verbose mode is off")"
		_1VERBOSE=0
	else
		_1VERBOSE=1
		_1verb "$(_1text "Verbose mode is on")"
	fi
}

# Generic complete function, finding formats
# @param 1st file format. 0 for none
# @param 2nd file format. 0 for none
# @param 3th file format. 0 for none
# @param 4th file format. 0 for none
# @param 5th file format. 0 for none
function _1compl {
  COMREPLY=()
  local word="${COMP_WORDS[COMP_CWORD]}"
    if [ "$COMP_CWORD" -eq 1 ] && [ $1 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$1" -- "$word"))
    elif [ "$COMP_CWORD" -eq 2 ] && [ $2 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$2" -- "$word"))
    elif [ "$COMP_CWORD" -eq 3 ] && [ $3 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$3" -- "$word"))    
    elif [ "$COMP_CWORD" -eq 4 ] && [ $4 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$4" -- "$word"))    
    elif [ "$COMP_CWORD" -eq 5 ] && [ $5 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$5" -- "$word"))    
    fi
}

# Returns all internal items of one kind
# @param Path
# @param File extension
# @param exclude extension? Default: yes
function _1list {
    local fn aux
    for fn in $(ls -1 "$1")
    do        
		if [ $# -gt 2 ]
		then
			echo -n " $fn"
		else
			aux="$(basename  "$fn" ".$2")"
			if [ "$aux" != "$fn" ]
			then
        		echo -n " $aux"
			fi
		fi
    done
}

# Creates and apply translation for NH1
# @param Language code
# @param Generate binaries. Default: none
function 1translate {
	local AUX
	case "$#" in
		1)
			pushd "$_1LIB"
			xgettext -o "locale/NH1.pot" -L Shell --keyword --keyword=_1text \
				"$_1DIR/nh1" "app.bashrc" "audio.bashrc" "backup.bashrc" \
				"canva.bashrc" "misc.bashrc" "network.bashrc" "rpg.bashrc"
			if [ -f "locale/$1.po" ]
			then
				msgmerge -U "locale/$1.po" "locale/NH1.pot"
			else
				msginit -o "locale/$1.po" -l "$1" -i "locale/NH1.pot"
			fi
			popd
			;;
		2)
			AUX="$_1LIB/locale/$1/LC_MESSAGES"
			mkdir -p "$AUX"
			msgfmt -o "$AUX/NH1.mo" "$_1LIB/locale/$1.po"
			;;
		*)
			printf "$(_1text "Usage: %s.")\n" "1translate <language-code> [compile]"
			;;
	esac
}

#MAIN

# Try to execute a `return` statement,
# but do it in a sub-shell and catch the results.
# If this script isn't sourced, that will raise an error.
if [ $# -gt 0 ]
then
	_1RUN=1$1
	shift
	$_1RUN $@
	unset _1RUN
else
	complete -W "$(_1list "$_1LIB/locale" "po")" 1translate

	_1modrun "_nh1-=-.complete"
	if return >/dev/null 2>&1
	then
		S1="source $_1RC"
		if ! grep "$S1" ~/.bashrc > /dev/null
		then
			NH1
		fi
		unset S1
	else
			echo "You need run: source $_1RC"
			return 0
	fi
fi