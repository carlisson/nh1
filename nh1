#!/bin/bash

shopt -s expand_aliases

# GLOBALS
_1VERSION=0.159

_1MODULES=(app audio backup canva misc network rpg)

_1DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
_1RC="$_1DIR/$(basename "${BASH_SOURCE[0]}")"
_1UDATA="$HOME/.norg"
_1GDATA="/opt/norg"

if [ "$_1DIR" = "/usr/bin" ]
then
	_1LIB="/usr/lib/norg"
elif [ "$_1DIR" = "/usr/local/bin" ]
then
	_1LIB="/usr/local/lib/norg"
else
	_1LIB="$_1DIR/lib"
fi

# Gettext configure
source gettext.sh
alias _1text="TEXTDOMAINDIR="$_1LIB/locale" gettext 'NH1'"

_1COLOR=6
_1PCOLOR=5 # Pending
_1XCOLOR=3 # Experimental
_1WCOLOR=2 # Working
_1DCOLOR=1 # Deprecated

_1MENUCOL=13
_1VERBOSE=0 # 0 - disabled; 1 - enabled

# Set text color in shell
# @param The color number (optional)
# @param Text to 1tint
function 1tint {
	local COLOR MSG

	case "$#" in
		0)
			_1text "You need to put a string and a color number (optional)"
			1tint 0 "0 $(_1text black)"; echo
			1tint 1 "1 $(_1text red)"; echo
			1tint 2 "2 $(_1text green)"; echo
			1tint 3 "3 $(_1text yellow)"; echo
			1tint 4 "4 $(_1text blue)"; echo
			1tint 5 "5 $(_1text magenta)"; echo
			1tint 6 "6 $(_1text cyan)"; echo
			1tint 7 "7 $(_1text white)"; echo
			return 1
			;;
		1) # param is text
			COLOR=$_1COLOR
			MSG=$1
			;;
		*) # every param after first is text
			COLOR=$1
			shift  
			MSG=$*
			;;
	esac

	tput setaf $COLOR
	echo -n $MSG
	tput sgr0

	return 0
}

# Print only if NH1 is in verbose mode
# @param Message to print
function _1verb {
	if [ $_1VERBOSE -gt 0 ]
	then
		1tint 3 "â–²"
		echo -n ' '
		1tint ${FUNCNAME[ 1 ]}
		echo ": $1"
	fi
}

# Run it for all modules
# @param Command. Replace -=- by module name
function _1modrun {
	local _COMM _MOD _AUX _COUNT
	_COMM="$1"
	_COUNT=0
	_1verb "$(printf "$(_1text "Running for %s")" "$_COMM")"

	for _MOD in "${_1MODULES[@]}"
	do
		_AUX=$(echo "$_COMM" | sed "s/-=-/$_MOD/")
		
		if [ "$(type -t $_AUX)" = 'function' ]
		then
			$_AUX
		elif [ "$(type -t $_AUX)" = 'builtin' ]
		then
			eval $_AUX
		else
			_COUNT=$((_COUNT+1))
		fi
	done
	_1verb "$(printf "$(_1text "Done. %i modules not ready for this command.")" $_COUNT)"
}

# IMPORT MODULES
_1modrun "source \"$_1LIB/-=-.bashrc\""

# Print a line to build help menu
# @param Status of command
# @param Command name
# @param Command description
# @param (optional) list of commands to check
function _1menuitem {
	if [ $# -gt 2 ]
	then
		# Possible status:
		#  W - working
		#  X - experimental
		#  P - planning
		#  D - deprecated
		local mi_status="$1"
		local mi_comm="$2"
		local mi_csize=${#mi_comm}
		local mi_descr="$3"
		local mi_color=7

		case "$mi_status" in
			"W") mi_color=$_1WCOLOR ;;
			"X") mi_color=$_1XCOLOR ;;
			"P") mi_color=$_1PCOLOR ;;
			"D") mi_color=$_1DCOLOR ;;
		esac

		if [ $# -gt 3 ]
		then
			if ! 1check -s "${@:4:$#+1}"
			then
				return
			fi
		fi

		if [ "$_1VERBOSE" = "1" ] || [ "$mi_status" = 'W' ] || [ "$mi_status" = "X" ]
		then
			local mi_spaces=$(($_1MENUCOL - $mi_csize +2))
			1tint $mi_color "$mi_comm"
			printf ' %.0s' $(seq 1 $mi_spaces)
			echo "$mi_descr"
		fi
	else
		_1text "You need to give status, command name, message and dependencies"
	fi
}

# Generic complete function, finding formats
# @param 1st file format. 0 for none
# @param 2nd file format. 0 for none
# @param 3th file format. 0 for none
# @param 4th file format. 0 for none
# @param 5th file format. 0 for none
function _1compl {
  COMREPLY=()
  local word="${COMP_WORDS[COMP_CWORD]}"
    if [ "$COMP_CWORD" -eq 1 ] && [ $1 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$1" -- "$word"))
    elif [ "$COMP_CWORD" -eq 2 ] && [ $2 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$2" -- "$word"))
    elif [ "$COMP_CWORD" -eq 3 ] && [ $3 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$3" -- "$word"))    
    elif [ "$COMP_CWORD" -eq 4 ] && [ $4 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$4" -- "$word"))    
    elif [ "$COMP_CWORD" -eq 5 ] && [ $5 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$5" -- "$word"))    
    fi
}

# Returns all internal items of one kind
# @param Path
# @param File extension
# @param exclude extension? Default: yes
function _1list {
    local fn aux
    for fn in $(ls -1 "$1")
    do        
		if [ $# -gt 2 ]
		then
			echo -n " $fn"
		else
			aux="$(basename  "$fn" ".$2")"
			if [ "$aux" != "$fn" ]
			then
        		echo -n " $aux"
			fi
		fi
    done
}


# Run the command as root
# @param Command
function _1sudo {
    if [ "$EUID" -eq 0 ]
    then
        $@
    else
        sudo $@
    fi
}

# Configure completion for main and file all modules.
function _nh1complete {
	complete -W "$(_1list "$_1LIB/locale" "po")" 1translate

	_1modrun "_nh1-=-.complete"
}

# Initial functions, configuring and create dirs
function _nh1init {
	mkdir -p "$_1UDATA"

	_1modrun "_nh1-=-.init"
}

# Apply custom variables to internals
function _nh1customvars {
	if [ -f "$_1UDATA/nh1.conf" ]
	then
		source "$_1UDATA/nh1.conf"
		if [[ $NORG_VERBOSE ]]
		then
			if [ "$NORG_VERBOSE" = "1" ]
			then
				_1VERBOSE=1
			else
				_1VERBOSE=0
			fi
			unset NORG_VERBOSE
		fi
	fi

	_1modrun "_nh1-=-.customvars"
}

# Check if a program exists. Finish NH1 if it do not exists.
# @param Program to check
function 1check {
	local CFAILS=0
	local SILENT=0
	for PROG in $*
	do
		if [ "$PROG" = "-s" ]
		then
		  SILENT=1
		else
			if [ -z "$(whereis -u "$PROG")" ]
			then
				if [ $SILENT -eq 1 ]
				then
	        		_1verb $(printf "$(_1text "%s is missing for %s")" $PROG $USER)
				else
					printf "$(_1text "Program %s does not exist or it is unavailable for %s.")\n" $PROG $USER
			  fi
				CFAILS=$((CFAILS+1))
			fi
		fi
	done
	if [ $CFAILS -gt 0 ]
	then
		return 1
	else
		return 0
	fi
}

# Clean all variables set by nh1
function 1clean {
	_1COLOR=1
	_1verb "$(_1text "Destroying all variables...")"

	_1modrun "_nh1-=-.clean"

	unset _1VERSION _1DIR _1RC _1LIB _1COLOR _1VERBOSE _1PCOLOR _1XCOLOR
	unset _1WCOLOR _1DCOLOR _1MENUCOL _1GDATA _1UDATA _1MODULES
	unalias _1text
	unset -f 1help 1tint _1sudo 1check 1bashrc 1refresh 1update 1version 
	unset -f 1clean 1help _1compl _1list 1translate _nh1complete _nh1init
	unset -f _nh1customvars 1info _1modrun 1verbose _1menuitem _1verb
}

# Menu for NH1
function 1help {
	local _MOD
		echo " -------------------------------------"
		echo -n "            "
    1tint "NH1 $_1VERSION"
		echo
		echo " -------------------------------------"
    echo

		# Load internal menus
		_1modrun _nh1-=-.menu
		
		echo "___ $(_1text "Main") ___"
		_1menuitem W 1bashrc "$(_1text "Modify .bashrc to NH1 starts on bash start")"
		_1menuitem W 1clean "$(_1text "Clean NH1 from memory (undo NH1 charge)")"
		_1menuitem W 1info "$(_1text "List possible custom variables")"
		_1menuitem W 1tint "$(_1text "Write a string in another color")"
		_1menuitem W 1translate "$(_1text "Create and apply translation for NH1.")"
		_1menuitem W 1update "$(_1text "Update your NH1, using git")" git
		_1menuitem W 1verbose "$(_1text "Enable/disable verbose mode")"
		_1menuitem W 1version "$(_1text "List NH1 version and latest changes/updates")"

		echo
		echo -n "   "
		1tint $_1PCOLOR $(_1text "planning")
		echo -n "   "
		1tint $_1XCOLOR $(_1text "experimental")
		echo -n "   "
		1tint $_1WCOLOR $(_1text "working")
		echo -n "   "
		1tint $_1DCOLOR $(_1text "deprecated")
		echo
		echo " -------------------------------------"
		echo "         $(_1text "Power-up your shell")"
		echo " -------------------------------------"
    echo
}

# Modify ~/.bashrc to init NH1 on bash start
function 1bashrc {
    local S1="source $_1RC"
    if grep "$S1" ~/.bashrc > /dev/null
    then
      _1text "NH1 is already installed in your profile. Run NH1 to see all commands available."
    else
		printf "$(_1text "Installing NH1 in %s...")\n" "$HOME/.bashrc"
    	echo "$S1" >> ~/.bashrc
			_1text "Done!"
    fi
}

# Reload NH1 and all related modules
function 1refresh {
	local LOCAL1RC=$_1RC
	_1verb "$(printf "$(_1text "After destroy variables, I will load %s.")" $_1RC)"
	1clean
	source "$LOCAL1RC"
	_1verb $(_1text "Done!")
}

# Update NH1 based in git repository
function 1update {
	if 1check git
	then
		pushd "$_1LIB/.." || return 1
		if [ -d ".git" ]
		then
			printf "$(_1text "NH1 was in version %s. ")" $_1VERSION
			git pull
			1refresh
			1version
			echo
		else
			_1text "You are using NH1 from tar-ball, not from Git."
		fi
		popd || return 2			
	else
		_1text "Git program is not available."
	fi
}

# List version software and list latest entries from changelog
function 1version {
	echo "NH1 $_1VERSION"
	echo
	tail "$_1LIB/changelog.txt"
}

# Enable or disable verbose mode
# @param (optional) Bit (0/1) to set verbose mode. Default: invvert current
function 1verbose {
	local NEWV=$_1VERBOSE
	if [ $# -eq 1 ]
	then
		if [ $1 -eq 1 ]
		then
			_1VERBOSE=1
			_1verb "$(_1text "Verbose mode is on")"
		else
			_1verb "$(_1text "Verbose mode is off")"
			_1VERBOSE=0
		fi
		return
	fi
	# invert verbose
	if [ $NEWV -eq 1 ]
	then
		_1verb "$(_1text "Verbose mode is off")"
		_1VERBOSE=0
	else
		_1VERBOSE=1
		_1verb "$(_1text "Verbose mode is on")"
	fi
}
# Creates and apply translation for NH1
# @param Language code
# @param Generate binaries. Default: none
function 1translate {
	local AUX
	case "$#" in
		1)
			_1verb "$(_1text "Generating translation file.")"
			pushd "$_1LIB" > /dev/null
			# Generate pot file for all modules
			xgettext -o "locale/NH1.pot" -L Shell --keyword --keyword=_1text \
				"$_1RC" $(echo ${_1MODULES[@]}' ' | sed 's/ /.bashrc /g') \
				$(_nh1app.avail | xargs -n 1 | sed 's/^\(.*\)$/recipes\/\1.app/g')
			_1verb "$(_1text ".pot file generated. Trying to create/update .po")"
			if [ -f "locale/$1.po" ]
			then
				msgmerge -U "locale/$1.po" "locale/NH1.pot"
			else
				msginit -o "locale/$1.po" -l "$1" -i "locale/NH1.pot"
			fi
			_1verb "$(_1text "Done!")"
			popd > /dev/null
			;;
		2)
			AUX="$_1LIB/locale/$1/LC_MESSAGES"
			mkdir -p "$AUX"
			_1verb "$(printf "$(_1text "Generating .mo file for %s language")" $1)"
			msgfmt -o "$AUX/NH1.mo" "$_1LIB/locale/$1.po"
			_1verb "$(_1text "Done!")"
			;;
		*)
			printf "$(_1text "Usage: %s.")\n" "1translate <language-code> [compile]"
			printf "$(_1text "Steps to translate"):\n"
			printf "  1) $(_1text "Run 1translate <language-code>. For example, 1translate pt_BR");\n"
			printf "  2) $(_1text "Edit the file <language-code>.po in %s, puting the translated strings");\n" "$_1LIB/locale"
			printf "  3) $(_1text "Run 1translate <language-code> build. This will generate .mo file. \"build\" can be replaced to anything");\n"
			printf "  4) $(_1text "Enjoy NH1 in your language! It's useful if you return translated .po to improve NH1 project!").\n"
			;;
	esac
}

# Information about user variables
function 1info {
	local _OLDMC
	echo "_______ $(_1text "Custom variables") _______"
	printf "$(_1text "You can configure custom variables for NH1. Edit %s to define it.")\n" "$_1UDATA/nh1.conf"

	_OLDMC=$_1MENUCOL
	_1MENUCOL=25

	_1menuitem W NORG_VERBOSE "$(_1text "Set verbose mode (1 or 0). Default: 0")"
	
	_1modrun "_nh1-=-.info"

	_1MENUCOL=$_OLDMC
}

#MAIN

# Try to execute a `return` statement,
# but do it in a sub-shell and catch the results.
# If this script isn't sourced, that will raise an error.

_nh1init
_nh1customvars

if [ $# -gt 0 ]
then
	_1RUN=1$1
	shift
	$_1RUN $@
	unset _1RUN
else

	_nh1complete

	if return >/dev/null 2>&1
	then
		S1="source $_1RC"
		if ! grep "$S1" ~/.bashrc > /dev/null
		then
			1help
		fi
		unset S1
	else
			printf "$(_1text "You need run: source %s.")\n" "$_1RC"
			return 0
	fi
fi