#!/bin/bash
# @file nh1
# @brief Simple shell end user swiss army knife (toolkit) 
# @description
#     A set of tools for shell.
#      * 1app - AppImage package manager
#      * audio, backup, network and rpg tools
#      * 1canva - create images from SVG templates
#      * other things
# Documentation for shdoc - https://github.com/reconquest/shdoc

shopt -s expand_aliases

# Global variables
_1VERSION=1.0n5

_1MODULES=(app audio backup canva misc network rpg)

_1DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
_1RC="$_1DIR/$(basename "${BASH_SOURCE[0]}")"
_1UDATA="$HOME/.norg"
_1GDATA="/opt/norg"

if [ "$_1DIR" = "/usr/bin" ]
then
	_1LIB="/usr/lib/norg"
	_1DOC="/usr/share/doc/norg"
elif [ "$_1DIR" = "/usr/local/bin" ]
then
	_1LIB="/usr/local/lib/norg"
	_1DOC="/usr/share/doc/norg"
else
	_1LIB="$_1DIR/lib"
	_1DOC="$_1DIR/doc"
fi

# Gettext configure
source gettext.sh
alias _1text="TEXTDOMAINDIR="$_1LIB/locale" gettext 'NH1'"

_1COLOR=6
_1PCOLOR=5 # Pending
_1XCOLOR=3 # Experimental
_1WCOLOR=2 # Working
_1DCOLOR=1 # Deprecated

_1MENUCOL=13
_1VERBOSE=0 # 0 - disabled; 1 - enabled

# @description Set text color in shell
#
# @example
#    echo "test: $(1tint 6 "Hello World")"
#
# @arg $1 int The color number (optional)
# @arg $2 string Text to color
#
# @exitcode 0 If successful.
# @exitcode 1 If an empty string passed.
1tint() {
	local COLOR MSG

	case "$#" in
		0)
			_1text "You need to put a string and a color number (optional)"
			1tint 0 "0 $(_1text black)"; echo
			1tint 1 "1 $(_1text red)"; echo
			1tint 2 "2 $(_1text green)"; echo
			1tint 3 "3 $(_1text yellow)"; echo
			1tint 4 "4 $(_1text blue)"; echo
			1tint 5 "5 $(_1text magenta)"; echo
			1tint 6 "6 $(_1text cyan)"; echo
			1tint 7 "7 $(_1text white)"; echo
			return 1
			;;
		1) # param is text
			COLOR=$_1COLOR
			MSG=$1
			;;
		*) # every param after first is text
			COLOR=$1
			shift  
			MSG=$*
			;;
	esac

	tput setaf $COLOR
	echo -n $MSG
	tput sgr0

	return 0
}

# @description Print only if NH1 is in verbose mode
#
# @arg $1 string Message to print
_1verb() {
	if [ $_1VERBOSE -gt 0 ]
	then
		1tint 3 "â–²"
		echo -n ' '
		1tint ${FUNCNAME[ 1 ]}
		echo ": $1"
	fi
}

# @description Run it for all modules
#
# @arg $1 command Replace -=- by module name
_1modrun() {
	local _COMM _MOD _AUX _COUNT
	_COMM="$1"
	_COUNT=0
	_1verb "$(printf "$(_1text "Running for %s")" "$_COMM")"

	for _MOD in "${_1MODULES[@]}"
	do
		_AUX=$(echo "$_COMM" | sed "s/-=-/$_MOD/g")
		
		if [ "$(type -t $_AUX)" = 'function' ]
		then
			#_1verb "$(printf "$(_1text "%s identified as a %s.")\n" "$_AUX" "function")"
			$_AUX
		elif [ "$(type -t $_AUX)" = 'builtin' ]
		then
			#_1verb "$(printf "$(_1text "%s identified as a %s.")\n" "$_AUX" "built-in")"
			eval $_AUX
		elif [ "$(type -t "$(echo "$_AUX" | cut -d\  -f 1)")" = "file" ]
		then
			#_1verb "$(printf "$(_1text "%s identified as a %s.")\n" "$_AUX" "file")"
			eval $_AUX
		else
			_COUNT=$((_COUNT+1))
		fi
	done
	_1verb "$(printf "$(_1text "Done. %i modules not ready for this command.")" $_COUNT)"
}

# IMPORT MODULES
_1modrun "source \"$_1LIB/-=-.bashrc\""

# @description Print a line to build help menu
# @arg $1 char Status of command (W, X, P or D: working, experimental, planning, deprecated)
# @arg $2 string Command name
# @arg $3 string Command description
# @arg $4 string list of commands to check (optional)
# @exitcode 0 If successful.
# @exitcode 1 Some command fail in checking
_1menuitem() {
	if [ $# -gt 2 ]
	then
		# Possible status:
		#  W - working
		#  X - experimental
		#  P - planning
		#  D - deprecated
		local mi_status="$1"
		local mi_comm="$2"
		local mi_csize=${#mi_comm}
		local mi_descr="$3"
		local mi_color=7

		case "$mi_status" in
			"W") mi_color=$_1WCOLOR ;;
			"X") mi_color=$_1XCOLOR ;;
			"P") mi_color=$_1PCOLOR ;;
			"D") mi_color=$_1DCOLOR ;;
		esac

		if [ $# -gt 3 ]
		then
			if ! 1check -s "${@:4:$#+1}"
			then
				return 1
			fi
		fi

		if [ "$_1VERBOSE" = "1" ] || [ "$mi_status" = 'W' ] || [ "$mi_status" = "X" ]
		then
			local mi_spaces=$(($_1MENUCOL - $mi_csize +2))
			1tint $mi_color "$mi_comm"
			printf ' %.0s' $(seq 1 $mi_spaces)
			echo "$mi_descr"
		fi
	else
		_1text "You need to give status, command name, message and dependencies"
	fi
	return 0
}

# @description Generic complete function, finding formats
# @arg $1 string 1st file format. 0 for none
# @arg $2 string 2nd file format. 0 for none
# @arg $3 string 3th file format. 0 for none
# @arg $4 string 4th file format. 0 for none
# @arg $5 string 5th file format. 0 for none
_1compl() {
  COMREPLY=()
  local word="${COMP_WORDS[COMP_CWORD]}"
    if [ "$COMP_CWORD" -eq 1 ] && [ $1 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$1" -- "$word"))
    elif [ "$COMP_CWORD" -eq 2 ] && [ $2 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$2" -- "$word"))
    elif [ "$COMP_CWORD" -eq 3 ] && [ $3 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$3" -- "$word"))    
    elif [ "$COMP_CWORD" -eq 4 ] && [ $4 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$4" -- "$word"))    
    elif [ "$COMP_CWORD" -eq 5 ] && [ $5 != "0" ]
    then
        COMPREPLY=($(compgen -f -X "!*.$5" -- "$word"))    
    fi
}

# @description Returns all internal items of one kind
# @arg $1 string Path
# @arg $2 string File extension
# @arg $3 string exclude extension? (Optional. Default: yes)
# @stdout The list of items
_1list() {
    local fn aux
    for fn in $(ls -1 "$1")
    do        
		if [ $# -gt 2 ]
		then
			echo -n " $fn"
		else
			aux="$(basename  "$fn" ".$2")"
			if [ "$aux" != "$fn" ]
			then
        		echo -n " $aux"
			fi
		fi
    done
}


# @description Run the command as root
# @arg $1 string Command
_1sudo() {
    if [ "$EUID" -eq 0 ]
    then
        $@
    else
        sudo $@
    fi
}

# @description Configure completion for main file and all modules.
# @see _1compl
_nh1complete() {
	complete -W "$(_1list "$_1LIB/locale" "po")" 1translate

	_1modrun "_nh1-=-.complete"
}

# @description Initial functions, configuring and creating dirs
_nh1init() {
	mkdir -p "$_1UDATA"

	_1modrun "_nh1-=-.init"
}

# @description Apply custom variables to internals
# @see 1info
_nh1customvars() {
	if [ -f "$_1UDATA/nh1.conf" ]
	then
		source "$_1UDATA/nh1.conf"
		if [[ $NORG_VERBOSE ]]
		then
			if [ "$NORG_VERBOSE" = "1" ]
			then
				_1VERBOSE=1
			else
				_1VERBOSE=0
			fi
			unset NORG_VERBOSE
		fi
	fi

	_1modrun "_nh1-=-.customvars"
}

# @description Check if a program exists. Finish NH1 if it do not exists.
# @arg $* string Program to check or "-s"
# @exitcode 0 Successful
# @exitcode 1 Fail in one or more checkings
1check() {
	local CFAILS=0
	local SILENT=0
	for PROG in $*
	do
		if [ "$PROG" = "-s" ]
		then
		  SILENT=1
		else
			if [ -z "$(whereis -b -B $(echo $PATH | tr ':' ' ') -f "$PROG" | sed "s/$PROG://")" ]
			then
				if [ $SILENT -eq 1 ]
				then
	        		_1verb "$(printf "$(_1text "%s is missing for %s")" $PROG $USER)"
				else
					printf "$(_1text "Program %s does not exist or it is unavailable for %s.")\n" $PROG $USER
			  fi
				CFAILS=$((CFAILS+1))
			fi
		fi
	done
	if [ $CFAILS -gt 0 ]
	then
		return 1
	else
		return 0
	fi
}

# @description Clean all variables defined by nh1
1clean() {
	_1COLOR=1
	_1verb "$(_1text "Destroying all variables...")"

	_1modrun "_nh1-=-.clean"

	unset _1VERSION _1DIR _1RC _1LIB _1COLOR _1VERBOSE _1PCOLOR _1XCOLOR
	unset _1WCOLOR _1DCOLOR _1MENUCOL _1GDATA _1UDATA _1MODULES _1DOC
	unalias _1text
	unset -f 1help 1tint _1sudo 1check 1bashrc 1refresh 1update 1version 
	unset -f 1clean 1help _1compl _1list 1translate _nh1complete _nh1init
	unset -f _nh1customvars 1info _1modrun 1verbose _1menuitem _1verb
}

# @description Menu for NH1.
# @see _1menuitem
1help() {
	local _MOD
		echo " -------------------------------------"
		echo -n "            "
    1tint "NH1 $_1VERSION"
		echo
		echo " -------------------------------------"
    echo

		# Load internal menus
		_1modrun _nh1-=-.menu
		
		echo "___ $(_1text "Main") ___"
		_1menuitem W 1bashrc "$(_1text "Modify .bashrc to NH1 starts on bash start")"
		_1menuitem W 1builddoc "$(_1text "Build documentation files for NH1")" shdoc
		_1menuitem W 1clean "$(_1text "Clean NH1 from memory (undo NH1 charge)")"
		_1menuitem W 1info "$(_1text "List possible custom variables")"
		_1menuitem W 1tint "$(_1text "Write a string in another color")"
		_1menuitem W 1translate "$(_1text "Create and apply translation for NH1.")"
		_1menuitem W 1update "$(_1text "Update your NH1, using git")" git
		_1menuitem W 1verbose "$(_1text "Enable/disable verbose mode")"
		_1menuitem W 1version "$(_1text "List NH1 version and latest changes/updates")"

		echo
		echo -n "   "
		1tint $_1PCOLOR $(_1text "planning")
		echo -n "   "
		1tint $_1XCOLOR $(_1text "experimental")
		echo -n "   "
		1tint $_1WCOLOR $(_1text "working")
		echo -n "   "
		1tint $_1DCOLOR $(_1text "deprecated")
		echo
		echo " -------------------------------------"
		echo "         $(_1text "Power-up your shell")"
		echo " -------------------------------------"
    echo
}

# @description Modify ~/.bashrc to init NH1 on bash start
1bashrc() {
    local S1="source $_1RC"
    if grep "$S1" ~/.bashrc > /dev/null
    then
      _1text "NH1 is already installed in your profile. Run NH1 to see all commands available."
    else
		printf "$(_1text "Installing NH1 in %s...")\n" "$HOME/.bashrc"
    	echo "$S1" >> ~/.bashrc
			_1text "Done!"
    fi
}

# @description Reload NH1 and all related modules
1refresh() {
	local LOCAL1RC=$_1RC
	_1verb "$(printf "$(_1text "After destroy variables, I will load %s.")" $_1RC)"
	1clean
	source "$LOCAL1RC"
	_1verb $(_1text "Done!")
}

# @description Update NH1 based in git repository
1update() {
	if 1check git
	then
		pushd "$_1LIB/.." || return 1
		if [ -d ".git" ]
		then
			printf "$(_1text "NH1 was in version %s. ")" $_1VERSION
			git pull
			1refresh
			1version
			echo
		else
			_1text "You are using NH1 from tar-ball, not from Git."
		fi
		popd || return 2			
	else
		_1text "Git program is not available."
	fi
}

# @description List software version and list latest entries from changelog
1version() {
	echo "NH1 $_1VERSION"
	echo
	tail "$_1LIB/changelog.txt"
}

# @description Enable or disable verbose mode
# @arg $1 int Bit (0/1) to set verbose mode. Default: invert current. (Optional)
# @see _1verb
1verbose() {
	local NEWV=$_1VERBOSE
	if [ $# -eq 1 ]
	then
		if [ $1 -eq 1 ]
		then
			_1VERBOSE=1
			_1verb "$(_1text "Verbose mode is on")"
		else
			_1verb "$(_1text "Verbose mode is off")"
			_1VERBOSE=0
		fi
		return
	fi
	# invert verbose
	if [ $NEWV -eq 1 ]
	then
		_1verb "$(_1text "Verbose mode is off")"
		_1VERBOSE=0
	else
		_1VERBOSE=1
		_1verb "$(_1text "Verbose mode is on")"
	fi
}

# @description Creates and applies translation for NH1
# @arg $1 string Language code
# @arg $2 string Generate binaries. Optional. Default: none
# @see _1text
1translate() {
	local AUX
	case "$#" in
		1)
			_1verb "$(_1text "Generating translation file.")"
			pushd "$_1LIB" > /dev/null
			# Generate pot file for all modules
			xgettext -o "locale/NH1.pot" -L Shell --keyword --keyword=_1text \
				"$_1RC" $(echo ${_1MODULES[@]}' ' | sed 's/ /.bashrc /g') \
				$(_nh1app.avail | xargs -n 1 | sed 's/^\(.*\)$/recipes\/\1.app/g')
			_1verb "$(_1text ".pot file generated. Trying to create/update .po")"
			if [ -f "locale/$1.po" ]
			then
				msgmerge -U "locale/$1.po" "locale/NH1.pot"
			else
				msginit -o "locale/$1.po" -l "$1" -i "locale/NH1.pot"
			fi
			_1verb "$(_1text "Done!")"
			popd > /dev/null
			;;
		2)
			AUX="$_1LIB/locale/$1/LC_MESSAGES"
			mkdir -p "$AUX"
			_1verb "$(printf "$(_1text "Generating .mo file for %s language")" $1)"
			msgfmt -o "$AUX/NH1.mo" "$_1LIB/locale/$1.po"
			_1verb "$(_1text "Done!")"
			;;
		*)
			printf "$(_1text "Usage: %s.")\n" "1translate <language-code> [compile]"
			printf "$(_1text "Steps to translate"):\n"
			printf "  1) $(_1text "Run 1translate <language-code>. For example, 1translate pt_BR");\n"
			printf "  2) $(_1text "Edit the file <language-code>.po in %s, puting the translated strings");\n" "$_1LIB/locale"
			printf "  3) $(_1text "Run 1translate <language-code> build. This will generate .mo file. \"build\" can be replaced to anything");\n"
			printf "  4) $(_1text "Enjoy NH1 in your language! It's useful if you return translated .po to improve NH1 project!").\n"
			;;
	esac
}

# @description Information about user variables
1info() {
	local _OLDMC
	echo "_______ $(_1text "Custom variables") _______"
	printf "$(_1text "You can configure custom variables for NH1. Edit %s to define it.")\n" "$_1UDATA/nh1.conf"

	_OLDMC=$_1MENUCOL
	_1MENUCOL=25

	_1menuitem W NORG_VERBOSE "$(_1text "Set verbose mode (1 or 0). Default: 0")"
	
	_1modrun "_nh1-=-.info"

	_1MENUCOL=$_OLDMC
}

# @description Build documentation
1builddoc() {
	local _INDEX
	_INDEX="$_1DOC/readme.md"
	if 1check shdoc
	then
    	_1verb "$(printf "$(_1text "Building documentation for nh1 %s...")" "$(_1text "main file")")"
    	shdoc < "$_1RC" > "$_1DOC/nh1.md"
		_1verb "$(printf "$(_1text "Building documentation for nh1 %s...")" "$(_1text "module files")")"    	
		_1modrun "shdoc < \"$_1LIB/-=-.bashrc\" > \"$_1DOC/-=-.md\""
		echo "# NH1 Documentation" > "$_INDEX"
		echo >> "$_INDEX"
		echo "Generated for NH1 $_1VERSION at $(date "+%Y-%m-%d")">> "$_INDEX"
		echo >> "$_INDEX"
		echo "## Index">> "$_INDEX"
		echo >> "$_INDEX"
		echo "* [Main file](nh1.md)">> "$_INDEX"
		_1modrun "echo \"* [-=- module](-=-.md)\" >> \"$_1DOC/readme.md\""
		printf "$(_1text "Documentation available in %s.")\n" "$_1DOC"
	fi
}

# @section Main Section

# Try to execute a `return` statement,
# but do it in a sub-shell and catch the results.
# If this script isn't sourced, that will raise an error.

_nh1customvars
_nh1init

if [ $# -gt 0 ]
then
	_1RUN=1$1
	shift
	$_1RUN $@
	unset _1RUN
else

	_nh1complete

	if return >/dev/null 2>&1
	then
		S1="source $_1RC"
		if ! grep "$S1" ~/.bashrc > /dev/null
		then
			1help
		fi
		unset S1
	else
			printf "$(_1text "You need run: source %s.")\n" "$_1RC"
			return 0
	fi
fi